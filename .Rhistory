df[(df$resMatrix[,1]>df$resMatrix[,2]),]
sim$sim_k
sim$sim_k>sim$s_n
sum(sim$sim_k>sim$s_n)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
dfMelt <- matrix(0,nrow = sum(df$resMatrix[,2]), ncol = ncol(df))
icnt <- 1
for(i in 1:nrow(df)){
if(df$resMatrix[i,1]){
for(j in 1:df$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(df[i,1:(dim(df)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(df$resMatrix[i,2]-df$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(df[i,1:(dim(df)[2]-1)]))
icnt <- icnt + 1
}
}
for(i in 1:nrow(df)){
if(df$resMatrix[i,1]>0){
for(j in 1:df$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(df[i,1:(dim(df)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(df$resMatrix[i,2]-df$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(df[i,1:(dim(df)[2]-1)]))
icnt <- icnt + 1
}
}
df$resMatrix[i,1]
df$resMatrix
#Simulated number of fish surviving
resMatrix <- as.matrix(cbind(sim$sim_k,sim$s_n))
resMatrix
#Create the dataframe for the lme4
df <- data.frame(yr=sim$yr,
julian = sim$j,
julian2 = (sim$j-mean(sim$j))^2,
var1=betas[,1],
var2=betas[,2])
#Standardize the julian date to make the estimation easier
df$julian <- (df$julian - mean(df$julian))/sd((df$julian))
df$julian2 <- (df$julian2 - mean(df$julian2))/sd((df$julian2))
#Add the resMatrix to the data.frame
df$resMatrix <- resMatrix
df$resMatrix
#update the data and the parameters
data$s_k <- sim$sim_k
parameters$eps_j <- parameters$eps_j*0
# #Create the object
sim_obj <- MakeADFun(data = data,
parameters = parameters,
map = myMap,
random=c("eps_j"
,"eps_t"
,"eps_jt"
,"eps_x"
,"frho_Rx"
),
silent = TRUE,
bias.correct=TRUE,
DLL = "integrated3_sim")
out_sim <- nlminb(sim_obj$par,sim_obj$fn,sim_obj$gr)   #Run the model
rep_sim <- sim_obj$report()   #Report the results
dfMelt <- matrix(0,nrow = sum(df$resMatrix[,2]), ncol = ncol(df))
icnt <- 1
for(i in 1:nrow(df)){
if(df$resMatrix[i,1]>0){
for(j in 1:df$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(df[i,1:(dim(df)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(df$resMatrix[i,2]-df$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(df[i,1:(dim(df)[2]-1)]))
icnt <- icnt + 1
}
}
dfMelt <- as.data.frame(dfMelt)
names(dfMelt) <- c(names(df)[1:5],"surv")
#Mized effect model using LME4
mod1 <- glm(surv~var1+var2+julian+julian2+yr*julian,
# control=glmerControl(optimizer = "bobyqa"),
# REML=FALSE,
data=dfMelt,
family="binomial")
#Get the standard for the TMB model
SD <- sdreport(sim_obj)
print(max(sim_obj$gr()))
print(SD)
print(max(sim_obj$gr()))
print(SD)
#Save the parameter and standard error estimates
mu_lme[ii,] <- c(plogis(coef(mod1)[1]),coef(mod1)[2:3])
coef(mod1)
plogis(coef(mod1)[1])
#Save the parameter and standard error estimates
mu_lme[ii,] <- c(plogis(coef(mod1)[1]),coef(mod1)[2:3])
mu_lme
mu_lme <- as.data.frame(matrix(NA,sim_n,3))
mu_TMB <- as.data.frame(matrix(NA,sim_n,3))
sd_lme <- as.data.frame(matrix(NA,sim_n,3))
sd_TMB <- as.data.frame(matrix(NA,sim_n,3))
names(mu_lme) <- c("mu", "beta[SST]","beta[CUI]")
names(mu_TMB) <- c("mu", "beta[SST]","beta[CUI]")
names(sd_lme) <- c("mu", "beta[SST]","beta[CUI]")
names(sd_TMB) <- c("mu", "beta[SST]","beta[CUI]")
#Save the parameter and standard error estimates
mu_lme[ii,] <- c(plogis(coef(mod1)[1]),coef(mod1)[2:3])
mu_TMB[ii,] <- c(plogis(SD$value[1]),SD$value[2:3])
sd_lme[ii,] <- sqrt(diag(vcov(mod1)))[1:3]
sd_TMB[ii,] <- SD$sd
sd_lme
mod1_pred <- plogis(predict(mod1))
df_obs <- data.frame(out=rep("obs",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=data$s_k/data$s_n)
df_MV <- data.frame(out=rep("MV",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=(rep_sim$s_hat))
# df_re <- data.frame(out=rep("re",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=mod1_pred)
df_fixed <- data.frame(out=rep("fixed",nrow(dfMelt)),yr=dfMelt$yr+2000, j=rep(df$julian,times=df$resMatrix[,2])+minJ, val=mod1_pred)
df_MV_mu <- data.frame(out=rep("MV_mean",(max(data$j)+1)*(max(data$yr)+1)),
yr=rep(sort(unique(data$yr)+2000),each=length(data$best_eps_j)),
j=rep(minJ:maxJ,times=length(unique(data$yr))),
val=plogis(rep_sim$mu_s+c(t(t(matrix(sim$s_eps_j,length(sim$s_eps_j),length(rep_sim$eMar2)))+rep_sim$eMar2))))
df <- rbind(df_obs,
df_MV,
df_fixed,
df_MV_mu)
print(ii)
source("fig_quadraticRealization_ggplot.r")
df_fixed
head(df_fixed)
df$julian
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
#Flags
use_best_eps_j <- 1 #use the eps_j from the MLE model (1=yes, 0=randomly generate)
re_j <- 1 #Estimate daily random effects
source("create_DataAndPars_sim3.r")
source("create_MapAndObj_sim3.r")
#Simulated data set
sim <- obj$simulate(complete=TRUE)
#Simulated number of fish surviving
resMatrix <- as.matrix(cbind(sim$sim_k,sim$s_n))
#Create the dataframe for the lme4
dfSim <- data.frame(yr=sim$yr,
julian = sim$j,
julian2 = (sim$j-mean(sim$j))^2,
var1=betas[,1],
var2=betas[,2])
#Standardize the julian date to make the estimation easier
dfSim$julian <- (dfSim$julian - mean(dfSim$julian))/sd((dfSim$julian))
dfSim$julian2 <- (dfSim$julian2 - mean(dfSim$julian2))/sd((dfSim$julian2))
#Add the resMatrix to the data.frame
dfSim$resMatrix <- resMatrix
#update the data and the parameters
data$s_k <- sim$sim_k
parameters$eps_j <- parameters$eps_j*0
# #Create the object
sim_obj <- MakeADFun(data = data,
parameters = parameters,
map = myMap,
random=c("eps_j"
,"eps_t"
,"eps_jt"
,"eps_x"
,"frho_Rx"
),
silent = TRUE,
bias.correct=TRUE,
DLL = "integrated3_sim")
out_sim <- nlminb(sim_obj$par,sim_obj$fn,sim_obj$gr)   #Run the model
rep_sim <- sim_obj$report()   #Report the results
dfMelt <- matrix(0,nrow = sum(df$resMatrix[,2]), ncol = ncol(dfSim))
icnt <- 1
dfMelt <- matrix(0,nrow = sum(dfSim$resMatrix[,2]), ncol = ncol(dfSim))
icnt <- 1
for(i in 1:nrow(dfSim)){
if(dfSim$resMatrix[i,1]>0){
for(j in 1:dfSim$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(dfSim$resMatrix[i,2]-dfSim$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
nrow(dfSim)
#Flags
use_best_eps_j <- 1 #use the eps_j from the MLE model (1=yes, 0=randomly generate)
re_j <- 1 #Estimate daily random effects
source("create_DataAndPars_sim3.r")
source("create_MapAndObj_sim3.r")
#Simulated data set
sim <- obj$simulate(complete=TRUE)
#Simulated number of fish surviving
resMatrix <- as.matrix(cbind(sim$sim_k,sim$s_n))
#Create the dataframe for the lme4
dfSim <- data.frame(yr=sim$yr,
julian = sim$j,
julian2 = (sim$j-mean(sim$j))^2,
var1=betas[,1],
var2=betas[,2])
#Standardize the julian date to make the estimation easier
dfSim$julian <- (dfSim$julian - mean(dfSim$julian))/sd((dfSim$julian))
dfSim$julian2 <- (dfSim$julian2 - mean(dfSim$julian2))/sd((dfSim$julian2))
#Add the resMatrix to the data.frame
dfSim$resMatrix <- resMatrix
#update the data and the parameters
data$s_k <- sim$sim_k
parameters$eps_j <- parameters$eps_j*0
# #Create the object
sim_obj <- MakeADFun(data = data,
parameters = parameters,
map = myMap,
random=c("eps_j"
,"eps_t"
,"eps_jt"
,"eps_x"
,"frho_Rx"
),
silent = TRUE,
bias.correct=TRUE,
DLL = "integrated3_sim")
out_sim <- nlminb(sim_obj$par,sim_obj$fn,sim_obj$gr)   #Run the model
rep_sim <- sim_obj$report()   #Report the results
dfMelt <- matrix(0,nrow = sum(dfSim$resMatrix[,2]), ncol = ncol(dfSim))
dim(dfSim)
icnt <- 1
nrow(dfSim)
dfSim$resMatrix[i,1]
for(i in 1:nrow(dfSim)){
if(dfSim$resMatrix[i,1]>0){
for(j in 1:dfSim$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(dfSim$resMatrix[i,2]-dfSim$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
dfMelt <- as.data.frame(dfMelt)
names(dfMelt) <- c(names(dfSim)[1:5],"surv")
#Mized effect model using LME4
mod1 <- glm(surv~var1+var2+julian+julian2+yr*julian,
# control=glmerControl(optimizer = "bobyqa"),
# REML=FALSE,
data=dfMelt,
family="binomial")
#Get the standard for the TMB model
SD <- sdreport(sim_obj)
print(max(sim_obj$gr()))
print(SD)
#Save the parameter and standard error estimates
mu_lme[ii,] <- c(plogis(coef(mod1)[1]),coef(mod1)[2:3])
mu_TMB[ii,] <- c(plogis(SD$value[1]),SD$value[2:3])
sd_lme[ii,] <- sqrt(diag(vcov(mod1)))[1:3]
sd_TMB[ii,] <- SD$sd
mod1_pred <- plogis(predict(mod1))
df_obs <- data.frame(out=rep("obs",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=data$s_k/data$s_n)
df_MV <- data.frame(out=rep("MV",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=(rep_sim$s_hat))
# df_re <- data.frame(out=rep("re",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=mod1_pred)
df_fixed <- data.frame(out=rep("fixed",nrow(dfMelt)),yr=dfMelt$yr+2000, j=rep(dfSim$julian,times=dfSim$resMatrix[,2])+minJ, val=mod1_pred)
df_MV_mu <- data.frame(out=rep("MV_mean",(max(data$j)+1)*(max(data$yr)+1)),
yr=rep(sort(unique(data$yr)+2000),each=length(data$best_eps_j)),
j=rep(minJ:maxJ,times=length(unique(data$yr))),
val=plogis(rep_sim$mu_s+c(t(t(matrix(sim$s_eps_j,length(sim$s_eps_j),length(rep_sim$eMar2)))+rep_sim$eMar2))))
dfAll <- rbind(df_obs,
df_MV,
df_fixed,
df_MV_mu)
print(ii)
source("fig_quadraticRealization_ggplot.r")
df_fixed
data$julian
data$j
data$j+minJ
# df_re <- data.frame(out=rep("re",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=mod1_pred)
df_fixed <- data.frame(out=rep("fixed",nrow(dfMelt)),yr=dfMelt$yr+2000, j=rep(data$j+minJ,times=dfSim$resMatrix[,2])+minJ, val=mod1_pred)
df_MV_mu <- data.frame(out=rep("MV_mean",(max(data$j)+1)*(max(data$yr)+1)),
yr=rep(sort(unique(data$yr)+2000),each=length(data$best_eps_j)),
j=rep(minJ:maxJ,times=length(unique(data$yr))),
val=plogis(rep_sim$mu_s+c(t(t(matrix(sim$s_eps_j,length(sim$s_eps_j),length(rep_sim$eMar2)))+rep_sim$eMar2))))
dfAll <- rbind(df_obs,
df_MV,
df_fixed,
df_MV_mu)
print(ii)
source("fig_quadraticRealization_ggplot.r")
df_fixed
df_fixed$j
range(df_fixed$j)
# df_re <- data.frame(out=rep("re",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=mod1_pred)
df_fixed <- data.frame(out=rep("fixed",nrow(dfMelt)),yr=dfMelt$yr+2000, j=rep(data$j,times=dfSim$resMatrix[,2])+minJ, val=mod1_pred)
df_MV_mu <- data.frame(out=rep("MV_mean",(max(data$j)+1)*(max(data$yr)+1)),
yr=rep(sort(unique(data$yr)+2000),each=length(data$best_eps_j)),
j=rep(minJ:maxJ,times=length(unique(data$yr))),
val=plogis(rep_sim$mu_s+c(t(t(matrix(sim$s_eps_j,length(sim$s_eps_j),length(rep_sim$eMar2)))+rep_sim$eMar2))))
dfAll <- rbind(df_obs,
df_MV,
df_fixed,
df_MV_mu)
print(ii)
source("fig_quadraticRealization_ggplot.r")
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
dfMelt <- matrix(0,nrow = sum(dfSim$resMatrix[,2]), ncol = ncol(dfSim))
icnt <- 1
for(i in 1:nrow(dfSim)){
if(dfSim$resMatrix[i,1]>0){
for(j in 1:dfSim$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(dfSim$resMatrix[i,2]-dfSim$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
nrow(dfSim)
icnt
sum(dfSim$resMatrix[,2])
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
ii
#Flags
use_best_eps_j <- 0 #use the eps_j from the MLE model (1=yes, 0=randomly generate)
re_j <- 1 #Estimate daily random effects
source("create_DataAndPars_sim3.r")
source("create_MapAndObj_sim3.r")
#Simulated data set
sim <- obj$simulate(complete=TRUE)
#Simulated number of fish surviving
resMatrix <- as.matrix(cbind(sim$sim_k,sim$s_n))
#Create the dataframe for the lme4
dfSim <- data.frame(yr=sim$yr,
julian = sim$j,
julian2 = (sim$j-mean(sim$j))^2,
var1=betas[,1],
var2=betas[,2])
#Standardize the julian date to make the estimation easier
dfSim$julian <- (dfSim$julian - mean(dfSim$julian))/sd((dfSim$julian))
dfSim$julian2 <- (dfSim$julian2 - mean(dfSim$julian2))/sd((dfSim$julian2))
#Add the resMatrix to the data.frame
dfSim$resMatrix <- resMatrix
#update the data and the parameters
data$s_k <- sim$sim_k
parameters$eps_j <- parameters$eps_j*0
# #Create the object
sim_obj <- MakeADFun(data = data,
parameters = parameters,
map = myMap,
random=c("eps_j"
,"eps_t"
,"eps_jt"
,"eps_x"
,"frho_Rx"
),
silent = TRUE,
bias.correct=TRUE,
DLL = "integrated3_sim")
out_sim <- nlminb(sim_obj$par,sim_obj$fn,sim_obj$gr)   #Run the model
rep_sim <- sim_obj$report()   #Report the results
dfMelt <- matrix(0,nrow = sum(dfSim$resMatrix[,2]), ncol = ncol(dfSim))
dim(dfMelt)
dfMelt <- matrix(0,nrow = sum(dfSim$resMatrix[,2]), ncol = ncol(dfSim))
icnt <- 1
for(i in 1:nrow(dfSim)){
if(dfSim$resMatrix[i,1]>0){
for(j in 1:dfSim$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(dfSim$resMatrix[i,2]-dfSim$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
dfSim$resMatrix[,1]>dfSim$resMatrix[,2]
sum(dfSim$resMatrix[,1]>dfSim$resMatrix[,2])
dfSim$resMatrix[i,1]
sim$sim_k
sum(sim$sim_k)
sim$s_n
sum(sim$s_n)
dfSim$resMatrix[i,2]-dfSim$resMatrix[i,1]
dfSim$resMatrix[,2]-dfSim$resMatrix[,1]
sum(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])
sum(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])+sum(dfSim$resMatrix[,1])
(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])
min(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
min(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])
i
dim(dfSim)
dfSim
head(dfSim)
melt(dfSim,id=c("yr","julian","julian2","var1","var2"))
rep(dfSim$yr,dfSim$resMatrix[,1])
dfSim$resMatrix[,1]
rep(dfSim$yr,dfSim$resMatrix[,1])
rbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1]))
cbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1]))
df_0 <- cbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1]))
df_1 <- cbind(rep(dfSim$yr,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$julian,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$julian2,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$var1,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$var2,(dfSim$resMatrix[,2])-dfSim$resMatrix[,1]))
df_1 <- cbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1]))
df_1$surv <- 1
df_1
df_1 <- cbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1]))
df_1 <- as.data.frame(cbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1])))
df_1$surv <- 1
df_0 <- as.data.frame(cbind(rep(dfSim$yr,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$julian,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$julian2,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$var1,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$var2,(dfSim$resMatrix[,2])-dfSim$resMatrix[,1])))
df_0$surv <- 0
names(df_0) <- c(names(dfSim)[1:5],"surv")
names(df_1) <- c(names(dfSim)[1:5],"surv")
dfMelt <- as.data.frame(rbind(df_0,df_1))
mod1 <- glm(surv~var1+var2+julian+julian2+yr*julian,
# control=glmerControl(optimizer = "bobyqa"),
# REML=FALSE,
data=dfMelt,
family="binomial")
dim(dfMelt)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/fig_quadraticSimulation_ggplot.r', echo=TRUE)
citation("glm")
glm
?glm
citation("stats")
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/fig_quadraticSimulation_ggplot.r', echo=TRUE)
mu_lme$Model <- "glm"
mu_TMB$Model <- "TMB"
mu_lme$stat <- "A"
mu_TMB$stat <- "A"
sd_lme$Model <- "glm"
sd_TMB$Model <- "TMB"
sd_lme$stat <- "B"
sd_TMB$stat <- "B"
df <- rbind(mu_lme,mu_TMB,sd_lme,sd_TMB)
df <- melt(df,
# measure.vars = names(simMat),
id.vars = c("Model","stat"),
variable.name="pars")
df <- na.omit(df)
df <- df[!(df$pars=="beta[SST]" & df$stat=="B" & df$value>100),]
df_par <- df
df$value[df$pars=="mu" & df$stat=="A"] <- (df$value[df$pars=="mu" & df$stat=="A"] - plogis(rep_true$mu_s))/plogis(rep$mu_s)*100
df$value[df$pars=="beta[CUI]" & df$stat=="A"] <- (df$value[df$pars=="beta[CUI]" & df$stat=="A"] - (rep_true$beta_mar[2,1]))/(rep_true$beta_mar[2,1])*100
df$value[df$pars=="beta[SST]" & df$stat=="A"] <- (df$value[df$pars=="beta[SST]" & df$stat=="A"] - (rep_true$beta_mar[1,1]))/(rep_true$beta_mar[1,1])*100
save(file="simQuadractic.rData",df, df_par)
source('C:/NOAA/PROJECTS/SAR_paper/fig_quadraticSimulation_ggplot.r', echo=TRUE)
med_points
pt_se
(pt_se$value[pt_se$Model=="TMB"] - pt_se$value[pt_se$Model=="glm"])/pt_se$value[pt_se$Model=="glm"]
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/fig_quadraticSimulation_ggplot.r', echo=TRUE)
265000/360
265000*2/360
