DLL = "integrated3_sim")
out_sim <- nlminb(sim_obj$par,sim_obj$fn,sim_obj$gr)   #Run the model
rep_sim <- sim_obj$report()   #Report the results
dfMelt <- matrix(0,nrow = sum(df$resMatrix[,2]), ncol = ncol(dfSim))
icnt <- 1
dfMelt <- matrix(0,nrow = sum(dfSim$resMatrix[,2]), ncol = ncol(dfSim))
icnt <- 1
for(i in 1:nrow(dfSim)){
if(dfSim$resMatrix[i,1]>0){
for(j in 1:dfSim$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(dfSim$resMatrix[i,2]-dfSim$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
nrow(dfSim)
#Flags
use_best_eps_j <- 1 #use the eps_j from the MLE model (1=yes, 0=randomly generate)
re_j <- 1 #Estimate daily random effects
source("create_DataAndPars_sim3.r")
source("create_MapAndObj_sim3.r")
#Simulated data set
sim <- obj$simulate(complete=TRUE)
#Simulated number of fish surviving
resMatrix <- as.matrix(cbind(sim$sim_k,sim$s_n))
#Create the dataframe for the lme4
dfSim <- data.frame(yr=sim$yr,
julian = sim$j,
julian2 = (sim$j-mean(sim$j))^2,
var1=betas[,1],
var2=betas[,2])
#Standardize the julian date to make the estimation easier
dfSim$julian <- (dfSim$julian - mean(dfSim$julian))/sd((dfSim$julian))
dfSim$julian2 <- (dfSim$julian2 - mean(dfSim$julian2))/sd((dfSim$julian2))
#Add the resMatrix to the data.frame
dfSim$resMatrix <- resMatrix
#update the data and the parameters
data$s_k <- sim$sim_k
parameters$eps_j <- parameters$eps_j*0
# #Create the object
sim_obj <- MakeADFun(data = data,
parameters = parameters,
map = myMap,
random=c("eps_j"
,"eps_t"
,"eps_jt"
,"eps_x"
,"frho_Rx"
),
silent = TRUE,
bias.correct=TRUE,
DLL = "integrated3_sim")
out_sim <- nlminb(sim_obj$par,sim_obj$fn,sim_obj$gr)   #Run the model
rep_sim <- sim_obj$report()   #Report the results
dfMelt <- matrix(0,nrow = sum(dfSim$resMatrix[,2]), ncol = ncol(dfSim))
dim(dfSim)
icnt <- 1
nrow(dfSim)
dfSim$resMatrix[i,1]
for(i in 1:nrow(dfSim)){
if(dfSim$resMatrix[i,1]>0){
for(j in 1:dfSim$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(dfSim$resMatrix[i,2]-dfSim$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
dfMelt <- as.data.frame(dfMelt)
names(dfMelt) <- c(names(dfSim)[1:5],"surv")
#Mized effect model using LME4
mod1 <- glm(surv~var1+var2+julian+julian2+yr*julian,
# control=glmerControl(optimizer = "bobyqa"),
# REML=FALSE,
data=dfMelt,
family="binomial")
#Get the standard for the TMB model
SD <- sdreport(sim_obj)
print(max(sim_obj$gr()))
print(SD)
#Save the parameter and standard error estimates
mu_lme[ii,] <- c(plogis(coef(mod1)[1]),coef(mod1)[2:3])
mu_TMB[ii,] <- c(plogis(SD$value[1]),SD$value[2:3])
sd_lme[ii,] <- sqrt(diag(vcov(mod1)))[1:3]
sd_TMB[ii,] <- SD$sd
mod1_pred <- plogis(predict(mod1))
df_obs <- data.frame(out=rep("obs",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=data$s_k/data$s_n)
df_MV <- data.frame(out=rep("MV",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=(rep_sim$s_hat))
# df_re <- data.frame(out=rep("re",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=mod1_pred)
df_fixed <- data.frame(out=rep("fixed",nrow(dfMelt)),yr=dfMelt$yr+2000, j=rep(dfSim$julian,times=dfSim$resMatrix[,2])+minJ, val=mod1_pred)
df_MV_mu <- data.frame(out=rep("MV_mean",(max(data$j)+1)*(max(data$yr)+1)),
yr=rep(sort(unique(data$yr)+2000),each=length(data$best_eps_j)),
j=rep(minJ:maxJ,times=length(unique(data$yr))),
val=plogis(rep_sim$mu_s+c(t(t(matrix(sim$s_eps_j,length(sim$s_eps_j),length(rep_sim$eMar2)))+rep_sim$eMar2))))
dfAll <- rbind(df_obs,
df_MV,
df_fixed,
df_MV_mu)
print(ii)
source("fig_quadraticRealization_ggplot.r")
df_fixed
data$julian
data$j
data$j+minJ
# df_re <- data.frame(out=rep("re",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=mod1_pred)
df_fixed <- data.frame(out=rep("fixed",nrow(dfMelt)),yr=dfMelt$yr+2000, j=rep(data$j+minJ,times=dfSim$resMatrix[,2])+minJ, val=mod1_pred)
df_MV_mu <- data.frame(out=rep("MV_mean",(max(data$j)+1)*(max(data$yr)+1)),
yr=rep(sort(unique(data$yr)+2000),each=length(data$best_eps_j)),
j=rep(minJ:maxJ,times=length(unique(data$yr))),
val=plogis(rep_sim$mu_s+c(t(t(matrix(sim$s_eps_j,length(sim$s_eps_j),length(rep_sim$eMar2)))+rep_sim$eMar2))))
dfAll <- rbind(df_obs,
df_MV,
df_fixed,
df_MV_mu)
print(ii)
source("fig_quadraticRealization_ggplot.r")
df_fixed
df_fixed$j
range(df_fixed$j)
# df_re <- data.frame(out=rep("re",length(data$s_k)),yr=data$yr+2000, j=data$j+minJ, val=mod1_pred)
df_fixed <- data.frame(out=rep("fixed",nrow(dfMelt)),yr=dfMelt$yr+2000, j=rep(data$j,times=dfSim$resMatrix[,2])+minJ, val=mod1_pred)
df_MV_mu <- data.frame(out=rep("MV_mean",(max(data$j)+1)*(max(data$yr)+1)),
yr=rep(sort(unique(data$yr)+2000),each=length(data$best_eps_j)),
j=rep(minJ:maxJ,times=length(unique(data$yr))),
val=plogis(rep_sim$mu_s+c(t(t(matrix(sim$s_eps_j,length(sim$s_eps_j),length(rep_sim$eMar2)))+rep_sim$eMar2))))
dfAll <- rbind(df_obs,
df_MV,
df_fixed,
df_MV_mu)
print(ii)
source("fig_quadraticRealization_ggplot.r")
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
dfMelt <- matrix(0,nrow = sum(dfSim$resMatrix[,2]), ncol = ncol(dfSim))
icnt <- 1
for(i in 1:nrow(dfSim)){
if(dfSim$resMatrix[i,1]>0){
for(j in 1:dfSim$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(dfSim$resMatrix[i,2]-dfSim$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
nrow(dfSim)
icnt
sum(dfSim$resMatrix[,2])
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
ii
#Flags
use_best_eps_j <- 0 #use the eps_j from the MLE model (1=yes, 0=randomly generate)
re_j <- 1 #Estimate daily random effects
source("create_DataAndPars_sim3.r")
source("create_MapAndObj_sim3.r")
#Simulated data set
sim <- obj$simulate(complete=TRUE)
#Simulated number of fish surviving
resMatrix <- as.matrix(cbind(sim$sim_k,sim$s_n))
#Create the dataframe for the lme4
dfSim <- data.frame(yr=sim$yr,
julian = sim$j,
julian2 = (sim$j-mean(sim$j))^2,
var1=betas[,1],
var2=betas[,2])
#Standardize the julian date to make the estimation easier
dfSim$julian <- (dfSim$julian - mean(dfSim$julian))/sd((dfSim$julian))
dfSim$julian2 <- (dfSim$julian2 - mean(dfSim$julian2))/sd((dfSim$julian2))
#Add the resMatrix to the data.frame
dfSim$resMatrix <- resMatrix
#update the data and the parameters
data$s_k <- sim$sim_k
parameters$eps_j <- parameters$eps_j*0
# #Create the object
sim_obj <- MakeADFun(data = data,
parameters = parameters,
map = myMap,
random=c("eps_j"
,"eps_t"
,"eps_jt"
,"eps_x"
,"frho_Rx"
),
silent = TRUE,
bias.correct=TRUE,
DLL = "integrated3_sim")
out_sim <- nlminb(sim_obj$par,sim_obj$fn,sim_obj$gr)   #Run the model
rep_sim <- sim_obj$report()   #Report the results
dfMelt <- matrix(0,nrow = sum(dfSim$resMatrix[,2]), ncol = ncol(dfSim))
dim(dfMelt)
dfMelt <- matrix(0,nrow = sum(dfSim$resMatrix[,2]), ncol = ncol(dfSim))
icnt <- 1
for(i in 1:nrow(dfSim)){
if(dfSim$resMatrix[i,1]>0){
for(j in 1:dfSim$resMatrix[i,1]){
dfMelt[icnt,ncol(dfMelt)] <- 1
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
for(j in 1:(dfSim$resMatrix[i,2]-dfSim$resMatrix[i,1])){
dfMelt[icnt,dim(dfMelt)[2]] <- 0
dfMelt[icnt,1:(dim(dfMelt)[2]-1)] <- t(as.vector(dfSim[i,1:(dim(dfSim)[2]-1)]))
icnt <- icnt + 1
}
}
dfSim$resMatrix[,1]>dfSim$resMatrix[,2]
sum(dfSim$resMatrix[,1]>dfSim$resMatrix[,2])
dfSim$resMatrix[i,1]
sim$sim_k
sum(sim$sim_k)
sim$s_n
sum(sim$s_n)
dfSim$resMatrix[i,2]-dfSim$resMatrix[i,1]
dfSim$resMatrix[,2]-dfSim$resMatrix[,1]
sum(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])
sum(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])+sum(dfSim$resMatrix[,1])
(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])
min(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
min(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])
i
dim(dfSim)
dfSim
head(dfSim)
melt(dfSim,id=c("yr","julian","julian2","var1","var2"))
rep(dfSim$yr,dfSim$resMatrix[,1])
dfSim$resMatrix[,1]
rep(dfSim$yr,dfSim$resMatrix[,1])
rbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1]))
cbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1]))
df_0 <- cbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1]))
df_1 <- cbind(rep(dfSim$yr,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$julian,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$julian2,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$var1,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$var2,(dfSim$resMatrix[,2])-dfSim$resMatrix[,1]))
df_1 <- cbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1]))
df_1$surv <- 1
df_1
df_1 <- cbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1]))
df_1 <- as.data.frame(cbind(rep(dfSim$yr,dfSim$resMatrix[,1]),
rep(dfSim$julian,dfSim$resMatrix[,1]),
rep(dfSim$julian2,dfSim$resMatrix[,1]),
rep(dfSim$var1,dfSim$resMatrix[,1]),
rep(dfSim$var2,dfSim$resMatrix[,1])))
df_1$surv <- 1
df_0 <- as.data.frame(cbind(rep(dfSim$yr,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$julian,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$julian2,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$var1,(dfSim$resMatrix[,2]-dfSim$resMatrix[,1])),
rep(dfSim$var2,(dfSim$resMatrix[,2])-dfSim$resMatrix[,1])))
df_0$surv <- 0
names(df_0) <- c(names(dfSim)[1:5],"surv")
names(df_1) <- c(names(dfSim)[1:5],"surv")
dfMelt <- as.data.frame(rbind(df_0,df_1))
mod1 <- glm(surv~var1+var2+julian+julian2+yr*julian,
# control=glmerControl(optimizer = "bobyqa"),
# REML=FALSE,
data=dfMelt,
family="binomial")
dim(dfMelt)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/fig_quadraticSimulation_ggplot.r', echo=TRUE)
citation("glm")
glm
?glm
citation("stats")
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/fig_quadraticSimulation_ggplot.r', echo=TRUE)
mu_lme$Model <- "glm"
mu_TMB$Model <- "TMB"
mu_lme$stat <- "A"
mu_TMB$stat <- "A"
sd_lme$Model <- "glm"
sd_TMB$Model <- "TMB"
sd_lme$stat <- "B"
sd_TMB$stat <- "B"
df <- rbind(mu_lme,mu_TMB,sd_lme,sd_TMB)
df <- melt(df,
# measure.vars = names(simMat),
id.vars = c("Model","stat"),
variable.name="pars")
df <- na.omit(df)
df <- df[!(df$pars=="beta[SST]" & df$stat=="B" & df$value>100),]
df_par <- df
df$value[df$pars=="mu" & df$stat=="A"] <- (df$value[df$pars=="mu" & df$stat=="A"] - plogis(rep_true$mu_s))/plogis(rep$mu_s)*100
df$value[df$pars=="beta[CUI]" & df$stat=="A"] <- (df$value[df$pars=="beta[CUI]" & df$stat=="A"] - (rep_true$beta_mar[2,1]))/(rep_true$beta_mar[2,1])*100
df$value[df$pars=="beta[SST]" & df$stat=="A"] <- (df$value[df$pars=="beta[SST]" & df$stat=="A"] - (rep_true$beta_mar[1,1]))/(rep_true$beta_mar[1,1])*100
save(file="simQuadractic.rData",df, df_par)
source('C:/NOAA/PROJECTS/SAR_paper/fig_quadraticSimulation_ggplot.r', echo=TRUE)
med_points
pt_se
(pt_se$value[pt_se$Model=="TMB"] - pt_se$value[pt_se$Model=="glm"])/pt_se$value[pt_se$Model=="glm"]
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_simQuadratic.R', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/fig_quadraticSimulation_ggplot.r', echo=TRUE)
265000/360
265000*2/360
eStartYr <- 2000 #start year of the environmental data
eLastYr <- 2015 #end year of the environmental data
library(TMB)
library(TMBhelper)
# rm(list=ls())
rootDir <- "C:/NOAA/PROJECTS/SAR_PAPER/" #root directory
setwd(rootDir)
eStartYr <- 2000 #start year of the environmental data
eLastYr <- 2015 #end year of the environmental data
startYr <- 2000 #start year of the pit data
lastYr <- 2015 #end year of the pit data
minJ <- 100
maxJ <- 190
ny <- 75 #number of projection years
setSeed <- TRUE
runSensitivity <- FALSE #Do you want to run a sensitivity analysis
numberOfMarineVariables <- 1 #number of marine variables
#Estimated (1 is estimate, 0 is don't estimate)
rearType <- c("W")
re_j <- 0 #Day effect
re_t <- 0 #Year effect
re_jt <- 0 #Day X Year effect
fixed_mar <- 1 #mar/env surv parameters
mean_s <- 1 #Mean survival parameters
cov_pars <- 0 #covariance parameters
calibration_flag <- 0 #run calibration (0= NO, 1= Yes)
calibration_files <- c("calibration.out",
"ch1_Historical_2020rerun_wild_sep90_bonarrival.out",
"ch1_Historical_2020rerun_wild_sep50_bonarrival.out",
"ch1_Historical_2020rerun_wild_bonarrival.out")
calibration_file <- calibration_files[1]
reCompile <- TRUE
getSD <- FALSE
retro <- 0 # 1 = do the retrospective, 0 = don't do the retrospective
#Do you want to create SAR projections for all of the models you just ran
nsim <- 1 #number of simulations
SensitivitySimulation <- 1 #Just pick a simulation number it doesn't matter which one
createSARProjections <- FALSE #Do you want to also do the projections
simRCP <- c("stationary", "8.5")
simQuants <- c("50")
if(setSeed){
set.seed(100)
}
AIC <- 100000
marVars <- c(
'ersstArc.win'
,'ersstWAcoast.sum'
,'ersstArc.spr'
,'cui.spr'
)
load("envData.rData")
marVars <- c(names(envdata)[2:13],names(envdata)[18:42])
# #Freshwater variables
fwVars <- c(
'F.S2.ParrSu'
# ,'F.S3.ParrF'
# ,'T.S2.ParrSu','T.S4.ParrW'
# ,'aprmayjunetempLGR','aprmayjuneflowLGR'
# ,'aprmayjunBON.scrollTEMP','aprmayjunFLOW.obs'
)
#Combine the marine and freshwater variables
myVars <-c(marVars)
#'Tranport' or 'In-river' - subset the pit data
myTrans <- c("In-river")
saveOutput <- TRUE
# names(AICoutput) <- c("AIC",
# "vars",
# "rear",
# "varNames",
# "re_j",
# "re_t",
# "re_jt",
# "nvar",
# "gr",
# "cor")
if(reCompile){
try(dyn.unload("integrated2.dll"))
compile("integrated2.cpp")
}
dyn.load("integrated2.dll")
icnt <- 0
jcnt <- 0
library(TMB)
library(mvtnorm)
library(matrixcalc)
library(corpcor)
load("pitTotal_Snake_condensed.Rdata")
pitTotal$year <-
as.numeric(as.character(pitTotal$year))
pitTotal <- pitTotal[pitTotal$year<=lastYr,]
head(pitTotal)
sum(pitTotal$Total)
if(!is.null(myTrans)){
pitTotal <-
pitTotal[pitTotal$trans_dam==myTrans,]
}
myTrans
sum(pitTotal$Total)
pitTotal <- pitTotal[pitTotal$julian>=minJ & pitTotal$julian<=maxJ,]
sum(pitTotal$Total)
285244/285660
1-285244/285660
(1-285244/285660)*100
install.packages("pROC")
library(pROC)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_modelRuns.r', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_modelRuns.r', echo=TRUE)
rep$s_hat
pred <- rep(rep$s_hat,data$s_n)
pred
sum(data$s_n)
pred <- rep(rep$s_hat,data$s_n)
obs <- NA
for(i in 1:length(data$s_n)){
obs <- c(obs,rep("surv",data$s_k[i]),rep("dead",data$s_n[i]-data$s_k[i]))
}
obs <- na.omit(obs)
length(obs)
length(pred)
library(pROC)
roc(obs,pred)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_modelRuns.r', echo=TRUE)
library(pROC)
pred <- rep(rep$s_hat,data$s_n)
obs <- NA
for(i in 1:length(data$s_n)){
obs <- c(obs,rep("surv",data$s_k[i]),rep("dead",data$s_n[i]-data$s_k[i]))
}
obs <- na.omit(obs)
roc(obs,pred)
source('C:/NOAA/PROJECTS/SAR_paper/wrapper_modelRuns.r', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/fig_ROC_analysis.r', echo=TRUE)
obs
hist(pred[obs=="dead"], breaks=seq(0,1,0.02))
hist(pred[obs=="surv"], breaks=seq(0,1,0.02))
hist(pred[obs=="dead"], breaks=seq(0,1,0.02))
source('C:/NOAA/PROJECTS/SAR_paper/fig_ROC_analysis.r', echo=TRUE)
pred(na.omit(pred))
pred <- na.omit(pred)
obs <- na.omit(obs)
roc(obs,pred)
source('C:/NOAA/PROJECTS/SAR_paper/fig_ROC_analysis.r', echo=TRUE)
source('C:/NOAA/PROJECTS/SAR_paper/fig_ROC_analysis.r', echo=TRUE)
pred
source('C:/NOAA/PROJECTS/SAR_paper/fig_ROC_analysis.r', echo=TRUE)
require(TMB)
compile("simple.cpp")
dyn.load(dynlib("simple"))
## Test data
set.seed(123)
y <- rep(1900:2010,each=2)
year <- factor(y)
quarter <- factor(rep(1:4,length.out=length(year)))
period <- factor((y > mean(y))+1)
## Random year+quarter effect, fixed period effect:
B <- model.matrix(~year+quarter-1)
A <- model.matrix(~period-1)
B <- as(B,"dgTMatrix")
A <- as(A,"dgTMatrix")
u <- rnorm(ncol(B)) ## logsdu=0
beta <- rnorm(ncol(A))*100
eps <- rnorm(nrow(B),sd=1) ## logsd0=0
x <- as.numeric( A %*% beta + B %*% u + eps )
## Fit model
obj <- MakeADFun(data=list(x=x, B=B, A=A),
parameters=list(u=u*0, beta=beta*0, logsdu=1, logsd0=1),
random="u",
DLL="simple",
silent=TRUE
)
opt <- nlminb(obj$par, obj$fn, obj$gr)
opt
dyn.unload(simple)
dyn.unload("simple")
dyn.unload("simple.dll")
